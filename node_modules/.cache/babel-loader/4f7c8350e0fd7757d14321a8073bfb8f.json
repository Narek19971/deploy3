{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Images = exports.CanvasContext = exports.Raw = exports.Arc = exports.Circle = exports.Rect = exports.Line = exports.CanvasComponent = exports.Image = exports.Shape = exports.Text = exports.Container = exports.Canvas = exports.ButtonTypes = exports.EventTypes = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _handlerToProps;\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar EventTypes = {\n  MOVE: 'mousemove',\n  MOUSE_DOWN: 'mousedown',\n  MOUSE_UP: 'mouseup',\n  KEY_DOWN: 'keydown',\n  KEY_UP: 'keyup',\n  WHEEL: 'wheel'\n};\nexports.EventTypes = EventTypes;\nvar ButtonTypes = {\n  LEFT: 'left',\n  MIDDLE: 'middle',\n  RIGHT: 'right' // 0=left, 1=middle, 2=right\n\n};\nexports.ButtonTypes = ButtonTypes;\nvar ButtonMap = [ButtonTypes.LEFT, ButtonTypes.MIDDLE, ButtonTypes.RIGHT];\n\nfunction drawShape(x, y, context, points, color, fill, close) {\n  context.save();\n  context.fillStyle = color;\n  context.strokeStyle = color;\n  context.beginPath();\n  context.moveTo(points[0].x + x, points[0].y + y);\n\n  for (var i = 1; i < points.length; i++) {\n    context.lineTo(points[i].x + x, points[i].y + y);\n  }\n\n  if (close) {\n    context.closePath();\n  }\n\n  if (fill) context.fill();\n  context.stroke();\n  context.restore();\n}\n\nvar okCodes = ['Space', 'Backslash', 'BracketLeft', 'BracketRight', 'Quote', 'Semicolon', 'Period', 'Comma', 'Slash', 'Backquote', 'Minus', 'Equal'];\n\nfunction getChar(_ref) {\n  var key = _ref.key,\n      code = _ref.code;\n\n  if (code.indexOf('Key') === 0 || code.indexOf('Digit') === 0 || code.indexOf('Numpad') === 0) {\n    // some though we don't want\n    if (code !== 'NumpadEnter') {\n      return key;\n    }\n  }\n\n  if (okCodes.includes(code)) {\n    return key;\n  } // if not key and not [in map, then no char for it\n\n}\n\nfunction getCode(_ref2) {\n  var code = _ref2.code;\n  return code;\n}\n\nvar handlerToProps = (_handlerToProps = {}, _defineProperty(_handlerToProps, EventTypes.MOVE, 'onMove'), _defineProperty(_handlerToProps, EventTypes.MOUSE_DOWN, 'onMouseDown'), _defineProperty(_handlerToProps, EventTypes.MOUSE_UP, 'onMouseUp'), _defineProperty(_handlerToProps, EventTypes.KEY_DOWN, 'onKeyDown'), _defineProperty(_handlerToProps, EventTypes.KEY_UP, 'onKeyUp'), _defineProperty(_handlerToProps, EventTypes.WHEEL, 'onWheel'), _handlerToProps);\n\nvar CanvasContext = _react.default.createContext({\n  context: null,\n  registerListener: null,\n  unregisterListener: null,\n  triggerRender: null,\n  loadImage: null\n});\n\nexports.CanvasContext = CanvasContext;\nvar canvasProps = {\n  width: _propTypes.default.number.isRequired,\n  height: _propTypes.default.number.isRequired,\n  captureAllKeyEvents: _propTypes.default.bool\n};\nvar canvasDefaultProps = {\n  captureAllKeyEvents: true\n};\nvar loadingMap = {};\nvar imageMap = {};\n\nfunction loadImage(src, cb) {\n  if (imageMap[src]) {\n    return imageMap[src];\n  }\n\n  if (loadingMap[src]) {\n    // if we've already registered this function, don't register it again\n    if (loadingMap[src].includes(cb)) {\n      return null;\n    }\n\n    loadingMap[src].push(cb);\n    return null;\n  } // else load it\n\n\n  var body = document.getElementsByTagName(\"body\")[0];\n  var img = document.createElement(\"img\");\n  img.src = src;\n\n  img.onload = function () {\n    imageMap[src] = img;\n\n    if (src in loadingMap) {\n      loadingMap[src].forEach(function (cb) {\n        cb(img);\n      });\n    }\n\n    delete loadingMap[src];\n  };\n\n  if (img.loaded) {\n    imageMap[src] = img;\n    return img;\n  } else {\n    if (!(src in loadingMap)) {\n      loadingMap[src] = [];\n    }\n\n    loadingMap[src].push(cb);\n  }\n\n  img.style.display = 'none';\n  body.append(img);\n  return null;\n}\n\nvar doRender = function doRender(element, context) {\n  var children = [];\n\n  if (element.type.length === 1) {\n    children = element.type(element.props);\n  } else if (element.type._context) {\n    // in this case the only child is the function to call with context\n    children = element.props.children(context);\n  } else {\n    // we've got a class component\n    // this is kinda awful for a variety of reasons\n    // and I imagine will cause a lot of bugs.\n    var inst = new element.type(element.props);\n    children = inst.render();\n  }\n\n  if (!Array.isArray(children)) {\n    children = [children];\n  }\n\n  children.forEach(function (child) {\n    if (!child) {\n      return;\n    }\n\n    doRender(child, context);\n  });\n};\n\nvar Canvas =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Canvas, _React$Component);\n\n  function Canvas(props) {\n    var _this;\n\n    _classCallCheck(this, Canvas);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Canvas).call(this, props));\n    _this.state = {\n      context: null\n    };\n    _this.indexList = [];\n    _this.reattachListeners = _this.reattachListeners.bind(_assertThisInitialized(_this));\n    _this.removeListeners = _this.removeListeners.bind(_assertThisInitialized(_this));\n    _this.handleMouseMove = _this.handleMouseMove.bind(_assertThisInitialized(_this));\n    _this.handleMouseUp = _this.handleMouseUp.bind(_assertThisInitialized(_this));\n    _this.handleMouseDown = _this.handleMouseDown.bind(_assertThisInitialized(_this));\n    _this.handleKeyDown = _this.handleKeyDown.bind(_assertThisInitialized(_this));\n    _this.handleKeyUp = _this.handleKeyUp.bind(_assertThisInitialized(_this));\n    _this.handleContextMenu = _this.handleContextMenu.bind(_assertThisInitialized(_this));\n    _this.handleWheel = _this.handleWheel.bind(_assertThisInitialized(_this));\n    _this.registerListener = _this.registerListener.bind(_assertThisInitialized(_this));\n    _this.unregisterListener = _this.unregisterListener.bind(_assertThisInitialized(_this));\n    _this.forceRerender = _this.forceRerender.bind(_assertThisInitialized(_this));\n    _this.triggerRender = _this.triggerRender.bind(_assertThisInitialized(_this)); // map of event to array of function callbacks\n\n    _this.listeners = {};\n    return _this;\n  }\n\n  _createClass(Canvas, [{\n    key: \"registerListener\",\n    value: function registerListener(event, fn) {\n      if (!this.listeners[event]) {\n        this.listeners[event] = [];\n      }\n\n      this.listeners[event].push(fn);\n    }\n  }, {\n    key: \"unregisterListener\",\n    value: function unregisterListener(event, fn) {\n      if (!this.listeners[event]) {\n        return;\n      }\n\n      var index = this.listeners[event].indexOf(fn);\n      if (index < 0) return;\n      this.listeners[event].splice(index, 1);\n    }\n  }, {\n    key: \"forceRerender\",\n    value: function forceRerender() {\n      this.forceUpdate();\n    }\n  }, {\n    key: \"getMyContext\",\n    value: function getMyContext() {\n      return {\n        context: this.state.context,\n        registerListener: this.registerListener,\n        unregisterListener: this.unregisterListener,\n        forceRerender: this.forceRerender,\n        triggerRender: this.triggerRender,\n        getImage: loadImage\n      };\n    }\n  }, {\n    key: \"componentWillUpdate\",\n    value: function componentWillUpdate(newProps) {\n      if (newProps.width !== this.canvas.width) {\n        this.canvas.width = newProps.width;\n      }\n\n      if (newProps.height !== this.canvas.height) {\n        this.canvas.height = newProps.height;\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.width !== this.canvas.width) {\n        this.canvas.width = this.props.width;\n      }\n\n      if (this.props.height !== this.canvas.height) {\n        this.canvas.height = this.props.height;\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.removeListeners();\n    }\n  }, {\n    key: \"removeListeners\",\n    value: function removeListeners() {\n      this.canvas.removeEventListener('touchmove', this.handleMouseMove);\n      this.canvas.removeEventListener('touchstart', this.handleMouseDown);\n      this.canvas.removeEventListener('touchend', this.handleMouseUp);\n      this.canvas.removeEventListener('mousemove', this.handleMouseMove);\n      this.canvas.removeEventListener('mousedown', this.handleMouseDown);\n      this.canvas.removeEventListener('mouseup', this.handleMouseUp);\n      this.canvas.removeEventListener('contextmenu', this.handleContextMenu);\n      window.removeEventListener('keydown', this.handleKeyDown);\n      window.removeEventListener('keyup', this.handleKeyUp);\n      this.canvas.removeEventListener('wheel', this.handleWheel);\n    }\n  }, {\n    key: \"reattachListeners\",\n    value: function reattachListeners() {\n      // remove previous event handlers. this is so we avoid\n      // double and triple triggering events\n      this.removeListeners();\n      this.canvas.addEventListener('touchmove', this.handleMouseMove);\n      this.canvas.addEventListener('touchstart', this.handleMouseDown);\n      this.canvas.addEventListener('touchend', this.handleMouseUp);\n      this.canvas.addEventListener('mousemove', this.handleMouseMove);\n      this.canvas.addEventListener('mousedown', this.handleMouseDown);\n      this.canvas.addEventListener('mouseup', this.handleMouseUp);\n      this.canvas.addEventListener('contextmenu', this.handleContextMenu);\n      window.addEventListener('keydown', this.handleKeyDown);\n      window.addEventListener('keyup', this.handleKeyUp);\n      this.canvas.addEventListener('wheel', this.handleWheel);\n    }\n  }, {\n    key: \"getRealCoords\",\n    value: function getRealCoords(event) {\n      var rect = this.canvas.getBoundingClientRect(); // if this is a touch event, handle it specially\n\n      if (event.touches) {\n        var handledTouches = [];\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = event.touches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _touch = _step.value;\n            handledTouches.push({\n              x: _touch.clientX - rect.left,\n              y: _touch.clientY - rect.top\n            });\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        if (handledTouches.length === 0) {\n          // touchend only has changedTouches\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = event.changedTouches[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var touch = _step2.value;\n              handledTouches.push({\n                x: touch.clientX - rect.left,\n                y: touch.clientY - rect.top\n              });\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        }\n\n        if (handledTouches.length === 0) {\n          // shouldn't happen but just in case\n          return {};\n        }\n\n        return {\n          x: handledTouches[0].x,\n          y: handledTouches[0].y,\n          touches: handledTouches\n        };\n      }\n\n      return {\n        x: event.clientX - rect.left,\n        y: event.clientY - rect.top\n      };\n    }\n  }, {\n    key: \"handleMouseMove\",\n    value: function handleMouseMove(event) {\n      this.triggerEvent(EventTypes.MOVE, this.getRealCoords(event));\n      event.preventDefault();\n    }\n  }, {\n    key: \"handleMouseDown\",\n    value: function handleMouseDown(event) {\n      this.triggerEvent(EventTypes.MOUSE_DOWN, _objectSpread({}, this.getRealCoords(event), {\n        button: ButtonMap[event.button]\n      }));\n      event.preventDefault();\n    }\n  }, {\n    key: \"handleMouseUp\",\n    value: function handleMouseUp(event) {\n      this.triggerEvent(EventTypes.MOUSE_UP, _objectSpread({}, this.getRealCoords(event), {\n        button: ButtonMap[event.button]\n      }));\n      event.preventDefault();\n    }\n  }, {\n    key: \"handleKeyDown\",\n    value: function handleKeyDown(event) {\n      var bodyEvent = event.target.tagName === 'BODY';\n\n      if (!bodyEvent && !this.props.captureAllKeyEvents) {\n        // if this event did not come from the body, check if\n        // we want to capture all events. If we do, capture it\n        // if not, ignore it\n        return;\n      }\n\n      this.triggerEvent(EventTypes.KEY_DOWN, {\n        char: getChar(event),\n        code: getCode(event)\n      });\n      event.preventDefault();\n    }\n  }, {\n    key: \"handleKeyUp\",\n    value: function handleKeyUp(event) {\n      var bodyEvent = event.target.tagName === 'BODY';\n\n      if (!bodyEvent && !this.props.captureAllKeyEvents) {\n        // if this event did not come from the body, check if\n        // we want to capture all events. If we do, capture it\n        // if not, ignore it\n        return;\n      }\n\n      this.triggerEvent(EventTypes.KEY_UP, {\n        char: getChar(event),\n        code: getCode(event)\n      });\n      event.preventDefault();\n    }\n  }, {\n    key: \"handleContextMenu\",\n    value: function handleContextMenu(event) {\n      event.preventDefault();\n    }\n  }, {\n    key: \"handleWheel\",\n    value: function handleWheel(event) {\n      // Firefox uses deltaY, but it's opposite of the normal wheel delta\n      var delta = event.wheelDelta || -event.deltaY;\n      this.triggerEvent(EventTypes.WHEEL, _objectSpread({}, this.getRealCoords(event), {\n        up: delta > 0\n      }));\n    }\n  }, {\n    key: \"triggerEvent\",\n    value: function triggerEvent(event, data) {\n      if (this.listeners[event]) {\n        this.listeners[event].forEach(function (fn) {\n          fn(data);\n        });\n      }\n\n      if (handlerToProps[event]) {\n        var propName = handlerToProps[event];\n        var propFn = this.props[propName];\n\n        if (propFn) {\n          propFn(data);\n        }\n      }\n    }\n  }, {\n    key: \"triggerRender\",\n    value: function triggerRender(component) {\n      var _this2 = this;\n\n      if (!component || !component.props || component.props.zIndex === undefined) {\n        return;\n      }\n\n      var zIndex = component.props.zIndex;\n\n      for (var i = zIndex + 1; i < this.indexList.length; i++) {\n        var list = this.indexList[i];\n\n        if (!list) {\n          // this can happen if we have a gap in the zindex\n          continue;\n        }\n\n        list.forEach(function (element) {\n          doRender(element, _this2.getMyContext());\n        });\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      this.indexList = [];\n      var newChildren = this.props.children;\n\n      if (this.props.enableExperimental) {\n        var handleChild = function handleChild(child) {\n          if (!child || _typeof(child) !== \"object\" || Array.isArray(child)) {\n            return child;\n          }\n\n          var props = child.props || {};\n          var workingIndex = props.zIndex === undefined ? 1 : props.zIndex;\n\n          var newProps = _objectSpread({}, props, {\n            zIndex: workingIndex\n          });\n\n          if (!_this3.indexList[workingIndex]) {\n            _this3.indexList[workingIndex] = [];\n          }\n\n          _this3.indexList[workingIndex].push(child);\n\n          return _react.default.cloneElement(child, newProps);\n        };\n\n        newChildren = this.props.children.map(function (child) {\n          if (Array.isArray(child)) {\n            return child.map(function (innerChild) {\n              return handleChild(innerChild);\n            });\n          }\n\n          return handleChild(child);\n        });\n      }\n\n      return _react.default.createElement(CanvasContext.Provider, {\n        value: this.getMyContext()\n      }, _react.default.createElement(\"canvas\", {\n        ref: function ref(c) {\n          if (c) {\n            var newContext = c.getContext('2d');\n\n            if (_this3.state.context !== newContext) {\n              _this3.canvas = c;\n\n              _this3.setState({\n                context: newContext\n              }, function () {\n                _this3.reattachListeners();\n              });\n            }\n          }\n        }\n      }, newChildren));\n    }\n  }]);\n\n  return Canvas;\n}(_react.default.Component);\n\nexports.Canvas = Canvas;\n;\nCanvas.propTypes = canvasProps;\nCanvas.defaultProps = canvasDefaultProps;\n\nvar Container = function Container(_ref3) {\n  var children = _ref3.children;\n\n  if (Array.isArray(children)) {\n    return _toConsumableArray(children);\n  } else {\n    return children;\n  }\n};\n\nexports.Container = Container;\n\nvar Text = function Text(_ref4) {\n  var children = _ref4.children,\n      x = _ref4.x,\n      y = _ref4.y,\n      color = _ref4.color,\n      font = _ref4.font;\n  return _react.default.createElement(CanvasContext.Consumer, null, function (_ref5) {\n    var context = _ref5.context;\n\n    if (!context) {\n      return null;\n    }\n\n    if (!color) {\n      color = \"#000\";\n    }\n\n    if (!font) {\n      font = \"12px Arial\";\n    }\n\n    context.save();\n    context.font = font;\n    context.fillStyle = color;\n\n    if (!Array.isArray(children)) {\n      children = [children];\n    }\n\n    context.fillText(children.join(''), x, y);\n    context.restore();\n  });\n};\n\nexports.Text = Text;\n\nvar Line = function Line(_ref6) {\n  var x = _ref6.x,\n      y = _ref6.y,\n      x2 = _ref6.x2,\n      y2 = _ref6.y2,\n      color = _ref6.color;\n  return _react.default.createElement(CanvasContext.Consumer, null, function (_ref7) {\n    var context = _ref7.context;\n\n    if (!context) {\n      return null;\n    }\n\n    context.save();\n    context.strokeStyle = color;\n    context.beginPath();\n    context.moveTo(x, y);\n    context.lineTo(x2, y2);\n    context.closePath();\n    context.stroke();\n    context.restore();\n  });\n};\n\nexports.Line = Line;\n\nvar Shape = function Shape(_ref8) {\n  var x = _ref8.x,\n      y = _ref8.y,\n      points = _ref8.points,\n      color = _ref8.color,\n      fill = _ref8.fill,\n      close = _ref8.close;\n\n  if (close === undefined) {\n    close = true;\n  }\n\n  return _react.default.createElement(CanvasContext.Consumer, null, function (_ref9) {\n    var context = _ref9.context;\n\n    if (!context) {\n      return null;\n    }\n\n    drawShape(x, y, context, points, color, fill, close);\n  });\n};\n\nexports.Shape = Shape;\n\nvar Rect = function Rect(_ref10) {\n  var x = _ref10.x,\n      y = _ref10.y,\n      x2 = _ref10.x2,\n      y2 = _ref10.y2,\n      color = _ref10.color,\n      fill = _ref10.fill;\n  var width = Math.abs(x2 - x);\n  var height = Math.abs(y2 - y);\n  return _react.default.createElement(Shape, {\n    x: x,\n    y: y,\n    points: [{\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: height\n    }, {\n      x: width,\n      y: height\n    }, {\n      x: width,\n      y: 0\n    }],\n    color: color,\n    fill: fill\n  });\n};\n\nexports.Rect = Rect;\nvar imagePropTypes = {\n  src: _propTypes.default.string.isRequired,\n  x: _propTypes.default.number.isRequired,\n  y: _propTypes.default.number.isRequired,\n  width: _propTypes.default.number.isRequired,\n  height: _propTypes.default.number.isRequired,\n  clip: _propTypes.default.shape({\n    x: _propTypes.default.number.isRequired,\n    y: _propTypes.default.number.isRequired,\n    width: _propTypes.default.number.isRequired,\n    height: _propTypes.default.number.isRequired\n  })\n};\n\nvar Image =\n/*#__PURE__*/\nfunction (_React$Component2) {\n  _inherits(Image, _React$Component2);\n\n  function Image() {\n    _classCallCheck(this, Image);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Image).apply(this, arguments));\n  }\n\n  _createClass(Image, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          src = _this$props.src,\n          x = _this$props.x,\n          y = _this$props.y,\n          width = _this$props.width,\n          height = _this$props.height,\n          clip = _this$props.clip;\n      var _this$context = this.context,\n          context = _this$context.context,\n          forceRerender = _this$context.forceRerender,\n          getImage = _this$context.getImage;\n\n      if (!context) {\n        return null;\n      }\n\n      var img = getImage(src, forceRerender);\n\n      if (!img) {\n        return null;\n      }\n\n      if (clip) {\n        var sx = clip.x,\n            sy = clip.y,\n            sw = clip.width,\n            sh = clip.height;\n        var iw = img.width;\n        var ih = img.height; // basically convert the clip coords from draw space to image space\n\n        var rw = iw / width;\n        var rh = ih / height;\n        var finalX = sx * rw;\n        var finalY = sy * rh;\n        context.drawImage(img, finalX, finalY, sw * rw, sh * rh, x, y, width, height);\n      } else {\n        context.drawImage(img, x, y, width, height);\n      }\n\n      return null;\n    }\n  }]);\n\n  return Image;\n}(_react.default.Component);\n\nexports.Image = Image;\n\n_defineProperty(Image, \"contextType\", CanvasContext);\n\n;\nImage.propTypes = imagePropTypes;\nvar imagesPropTypes = {\n  images: _propTypes.default.arrayOf(_propTypes.default.shape({\n    src: _propTypes.default.string.isRequired,\n    x: _propTypes.default.number.isRequired,\n    y: _propTypes.default.number.isRequired,\n    width: _propTypes.default.number.isRequired,\n    height: _propTypes.default.number.isRequired,\n    clip: _propTypes.default.shape({\n      x: _propTypes.default.number.isRequired,\n      y: _propTypes.default.number.isRequired,\n      width: _propTypes.default.number.isRequired,\n      height: _propTypes.default.number.isRequired\n    })\n  }))\n};\n\nvar Images =\n/*#__PURE__*/\nfunction (_React$Component3) {\n  _inherits(Images, _React$Component3);\n\n  function Images() {\n    _classCallCheck(this, Images);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Images).apply(this, arguments));\n  }\n\n  _createClass(Images, [{\n    key: \"render\",\n    value: function render() {\n      var images = this.props.images;\n      var _this$context2 = this.context,\n          context = _this$context2.context,\n          forceRerender = _this$context2.forceRerender,\n          getImage = _this$context2.getImage;\n\n      if (!context) {\n        return null;\n      }\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = images[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var image = _step3.value;\n          var src = image.src,\n              x = image.x,\n              y = image.y,\n              width = image.width,\n              height = image.height,\n              clip = image.clip;\n          var img = getImage(src, forceRerender);\n\n          if (!img) {\n            continue;\n          }\n\n          if (clip) {\n            var sx = clip.x,\n                sy = clip.y,\n                sw = clip.width,\n                sh = clip.height;\n            var iw = img.width;\n            var ih = img.height; // basically convert the clip coords from draw space to image space\n\n            var rw = iw / width;\n            var rh = ih / height;\n            var finalX = sx * rw;\n            var finalY = sy * rh;\n            context.drawImage(img, finalX, finalY, sw * rw, sh * rh, x, y, width, height);\n          } else {\n            context.drawImage(img, x, y, width, height);\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return Images;\n}(_react.default.Component);\n\nexports.Images = Images;\n\n_defineProperty(Images, \"contextType\", CanvasContext);\n\n;\nImages.propTypes = imagesPropTypes;\n\nvar Arc = function Arc(_ref11) {\n  var x = _ref11.x,\n      y = _ref11.y,\n      radius = _ref11.radius,\n      startAngle = _ref11.startAngle,\n      endAngle = _ref11.endAngle,\n      color = _ref11.color,\n      fill = _ref11.fill,\n      sector = _ref11.sector,\n      closed = _ref11.closed;\n  return _react.default.createElement(CanvasContext.Consumer, null, function (_ref12) {\n    var context = _ref12.context;\n\n    if (!context) {\n      return null;\n    }\n\n    context.save();\n    context.strokeStyle = color;\n    context.fillStyle = color;\n    context.beginPath();\n\n    if (sector) {\n      context.moveTo(x, y);\n    }\n\n    context.arc(x, y, radius, startAngle, endAngle);\n\n    if (sector) {\n      context.moveTo(x, y);\n    }\n\n    if (closed) {\n      context.closePath();\n    }\n\n    if (!fill) {\n      context.stroke();\n    } else {\n      context.fill();\n    }\n\n    context.restore();\n  });\n};\n\nexports.Arc = Arc;\n\nvar Circle = function Circle(_ref13) {\n  var x = _ref13.x,\n      y = _ref13.y,\n      radius = _ref13.radius,\n      color = _ref13.color,\n      fill = _ref13.fill;\n  return _react.default.createElement(Arc, {\n    x: x,\n    y: y,\n    radius: radius,\n    startAngle: 0,\n    endAngle: 2 * Math.PI,\n    color: color,\n    fill: fill\n  });\n};\n\nexports.Circle = Circle;\n\nvar Raw = function Raw(_ref14) {\n  var drawFn = _ref14.drawFn;\n  return _react.default.createElement(CanvasContext.Consumer, null, function (_ref15) {\n    var context = _ref15.context;\n\n    if (!context) {\n      return null;\n    }\n\n    context.save();\n    drawFn(context);\n    context.restore();\n  });\n};\n\nexports.Raw = Raw;\n\nvar CanvasComponent =\n/*#__PURE__*/\nfunction (_React$Component4) {\n  _inherits(CanvasComponent, _React$Component4);\n\n  function CanvasComponent(props) {\n    var _this4;\n\n    _classCallCheck(this, CanvasComponent);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(CanvasComponent).call(this, props));\n    _this4.bounds = null;\n    _this4.handleMove = _this4.handleMove.bind(_assertThisInitialized(_this4));\n    _this4.handleUp = _this4.handleUp.bind(_assertThisInitialized(_this4));\n    _this4.handleDown = _this4.handleDown.bind(_assertThisInitialized(_this4));\n    _this4.onKeyDown = _this4.onKeyDown.bind(_assertThisInitialized(_this4));\n    _this4.onKeyUp = _this4.onKeyUp.bind(_assertThisInitialized(_this4));\n    _this4.handleWheel = _this4.handleWheel.bind(_assertThisInitialized(_this4));\n    return _this4;\n  }\n\n  _createClass(CanvasComponent, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (!this.context.registerListener) {\n        console.error('Unable to get child context for CanvasComponent-likely it is not nested inside a Canvas');\n        return;\n      }\n\n      this.context.registerListener(EventTypes.MOVE, this.handleMove);\n      this.context.registerListener(EventTypes.MOUSE_UP, this.handleUp);\n      this.context.registerListener(EventTypes.MOUSE_DOWN, this.handleDown);\n      this.context.registerListener(EventTypes.KEY_DOWN, this.onKeyDown);\n      this.context.registerListener(EventTypes.KEY_DOWN, this.onKeyUp);\n      this.context.registerListener(EventTypes.WHEEL, this.handleWheel);\n    }\n  }, {\n    key: \"insideMe\",\n    value: function insideMe(x, y) {\n      if (!this.bounds) {\n        return false;\n      }\n\n      return x > this.bounds.x && x < this.bounds.x + this.bounds.width && y > this.bounds.y && y < this.bounds.y + this.bounds.height;\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(data) {\n      var insideMe = this.insideMe(data.x, data.y);\n      this.onMouseMove(data, insideMe);\n    }\n  }, {\n    key: \"handleUp\",\n    value: function handleUp(data) {\n      var insideMe = this.insideMe(data.x, data.y);\n      this.onMouseUp(data, insideMe);\n    }\n  }, {\n    key: \"handleDown\",\n    value: function handleDown(data) {\n      var insideMe = this.insideMe(data.x, data.y);\n      this.onMouseDown(data, insideMe);\n    }\n  }, {\n    key: \"handleWheel\",\n    value: function handleWheel(data) {\n      var insideMe = this.insideMe(data.x, data.y);\n      this.onWheel(data, insideMe);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (!this.context.unregisterListener) {\n        console.error('Unable to get child context for CanvasComponent-likely it is not nested inside a Canvas');\n        return;\n      }\n\n      this.context.unregisterListener(EventTypes.MOVE, this.handleMove);\n      this.context.unregisterListener(EventTypes.MOUSE_UP, this.handleUp);\n      this.context.unregisterListener(EventTypes.MOUSE_DOWN, this.handleDown);\n      this.context.unregisterListener(EventTypes.KEY_DOWN, this.onKeyDown);\n      this.context.unregisterListener(EventTypes.KEY_DOWN, this.onKeyUp);\n      this.context.unregisterListener(EventTypes.WHEEL, this.handleWheel);\n    } // stubs\n\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove() {}\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp() {}\n  }, {\n    key: \"onMouseDown\",\n    value: function onMouseDown() {}\n  }, {\n    key: \"onKeyDown\",\n    value: function onKeyDown() {}\n  }, {\n    key: \"onKeyUp\",\n    value: function onKeyUp() {}\n  }, {\n    key: \"onWheel\",\n    value: function onWheel() {}\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this5 = this;\n\n      if (this.context.triggerRender) {\n        setTimeout(function () {\n          _this5.context.triggerRender(_this5);\n        }, 0);\n      }\n    }\n  }]);\n\n  return CanvasComponent;\n}(_react.default.Component);\n\nexports.CanvasComponent = CanvasComponent;\n\n_defineProperty(CanvasComponent, \"contextType\", CanvasContext);\n\nCanvasComponent.contextType = CanvasContext;","map":null,"metadata":{},"sourceType":"script"}